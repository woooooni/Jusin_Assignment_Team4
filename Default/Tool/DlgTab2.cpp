// DlgTab2.cpp : 구현 파일입니다.
//

#include "stdafx.h"
#include "Tool.h"
#include "DlgTab2.h"
#include "afxdialogex.h"
#include "FileInfo_KJM.h"  //  파일 명 다듬는 용 

// CDlgTab2 대화 상자입니다.

IMPLEMENT_DYNAMIC(CDlgTab2, CDialogEx)

CDlgTab2::CDlgTab2(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_DIALOG_TAB2, pParent)
{

}

CDlgTab2::~CDlgTab2()
{
}

void CDlgTab2::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	//DDX_Control(pDX, IDC_LIST1, Picture_Control);
	DDX_Control(pDX, IDC_LIST1, m_PictureListBox);
	DDX_Control(pDX, IDC_PictureStatic_KJM, m_AnimPicture);
}


BEGIN_MESSAGE_MAP(CDlgTab2, CDialogEx)
	//ON_BN_CLICKED(IDC_BUTTON1, &CDlgTab2::OnBnClickedPrint)
	//ON_LBN_SELCHANGE(IDC_LIST1, &CDlgTab2::OnLbnSelchangeList)
	ON_WM_DROPFILES()
	ON_LBN_SELCHANGE(IDC_LIST1, &CDlgTab2::OnLbnSelchangePictureList)
	
	ON_BN_CLICKED(IDC_BUTTON1, &CDlgTab2::OnBnClickedDeleteButton)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN1, &CDlgTab2::OnDeltaposSpinAnimPicture)
	ON_BN_CLICKED(IDC_BUTTON2, &CDlgTab2::OnBnClickedButtonPlay)
END_MESSAGE_MAP()


// CDlgTab2 메시지 처리기입니다.



void CDlgTab2::OnDropFiles(HDROP hDropInfo)
{
	
	UpdateData(TRUE);
	CDialog::OnDropFiles(hDropInfo);

	TCHAR		szFilePath[MAX_PATH] = L"";
	TCHAR		szFileName[MIN_STR] = L"";

	//DragQueryFile : 드롭된 파일을 정보를 얻어오는 함수
	// 0xffffffff(-1)로 지정하면 드롭된 파일의 개수를 반환
	int iFileCnt = DragQueryFile(hDropInfo, 0xffffffff, nullptr, 0);

	for (int i = 0; i < iFileCnt; ++i)
	{
		DragQueryFile(hDropInfo, i, szFilePath, MAX_PATH);

		CString strRelative = CFileInfo_KJM::ConvertRelativePath(szFilePath);
		CString	strFileName = PathFindFileName(strRelative);

		lstrcpy(szFileName, strFileName.GetString());
		PathRemoveExtension(szFileName);

		strFileName = szFileName;

		auto	iter = m_mapPngImg.find(strFileName);

		if (iter == m_mapPngImg.end())
		{
			CImage*	pPngImg = new CImage;
			pPngImg->Load(strRelative);

			m_mapPngImg.insert({ strFileName, pPngImg });
			m_PictureListBox.AddString(szFileName);
		}

	}

	//Horizontal_Scroll();  //  가로 스크롤은 안 쓸거 같음

	UpdateData(FALSE);

	CDialogEx::OnDropFiles(hDropInfo);
}


void CDlgTab2::OnLbnSelchangePictureList()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);


	CString			strSelectName;

	int	iSelect = m_PictureListBox.GetCurSel();

	if (LB_ERR == iSelect)
		return;

	m_PictureListBox.GetText(iSelect, strSelectName);

	auto iter = m_mapPngImg.find(strSelectName);

	if (iter == m_mapPngImg.end())
		return;


	m_AnimPicture.SetBitmap(*(iter->second)); // 애니메이션에 쓸 이미지 출력하고 있음

	int i = 0;

	for (; i < strSelectName.GetLength(); ++i)
	{
		// isdigit : 매개 변수로 전달받은 문자가 숫자형태의 글자인지 아니면 글자형태의 글자인지 판별하는 함수
		// 숫자형태의 글자로 판별하면 0이 아닌 값을 반환

		if (0 != isdigit(strSelectName[i]))
			break;
	}

	// Delete(index, count) : 인덱스 위치로부터 카운트만큼 문자를 삭제하는 함수
	strSelectName.Delete(0, i);

	//_tstoi : 문자를 정수형으로 변환하는 함수
	m_iDrawID = _tstoi(strSelectName);



	CImage* pImage = iter->second; //  이미지 포인터에 이미지 값을 저장


	CRect PictureControlRect; // Picture control 렉트 정보를 저장 ->렉트 크기
	m_AnimPicture.GetWindowRect(&PictureControlRect);
	ScreenToClient(&PictureControlRect);


	CImage resizedImage; // 크기에 맞게 조정하기 위해 저장할 이미지
	resizedImage.Create(PictureControlRect.Width(),
		PictureControlRect.Height(),
		pImage->GetBPP()); // 이미지 정보 출력 


	CDC* pDC = CDC::FromHandle(resizedImage.GetDC());
	CDC* pSrcDC = CDC::FromHandle(pImage->GetDC());


	// 이미지 스트레칭
	pDC->SetStretchBltMode(HALFTONE);
	pDC->StretchBlt(0, 0, 
		PictureControlRect.Width(),
		PictureControlRect.Height(),
		pSrcDC, 0, 0, pImage->GetWidth(), 
		pImage->GetHeight(), 
		SRCCOPY);

	resizedImage.ReleaseDC();
	
//	pImage->Destroy();
//	pImage->Attach(resizedImage.Detach());



	// Picture Control에 이미지 그리기
	
	CDC* pPictureDC = m_AnimPicture.GetDC();
	CRect pictureRect;
	
	m_AnimPicture.GetClientRect(&pictureRect);
	
	pPictureDC->FillSolidRect(&pictureRect, RGB(255, 255, 255)); // Picture Control 배경을 흰색으로 채우기
	
	pImage->Draw(pPictureDC->m_hDC, pictureRect);

	m_AnimPicture.ReleaseDC(pPictureDC);



	UpdateData(FALSE);

}





void CDlgTab2::OnBnClickedDeleteButton()
{
	// TODO: Add your control notification handler code here

	UpdateData(TRUE);

	CString		strFindName = L"";

	int		iSelect = m_PictureListBox.GetCurSel();

	if (LB_ERR == iSelect)
		return;



	m_PictureListBox.GetText(iSelect, strFindName);

	auto& iter = m_mapPngImg.find(strFindName);

	if (iter == m_mapPngImg.end())
		return;

	CImage* pImage = iter->second;
	

	//Safe_Delete(pImage);


	m_mapPngImg.erase(strFindName);

	m_PictureListBox.DeleteString(iSelect);

	

	UpdateData(FALSE);

}



void CDlgTab2::OnDeltaposSpinAnimPicture(NMHDR *pNMHDR, LRESULT *pResult)
{


	LPNMUPDOWN pNMUpDown = reinterpret_cast<LPNMUPDOWN>(pNMHDR);

	pNMUpDown->iDelta *= 1;

	CString			strSelectName;

	int		iSelect = m_PictureListBox.GetCurSel();

	if (LB_ERR == iSelect)
		return;


	iSelect += pNMUpDown->iDelta;  // 스핀 버튼의 방향에 따라 인덱스 변경

									 // 인덱스가 범위를 벗어나지 않도록 처리
	if (iSelect < 0)
	{
		iSelect = 0;
	}
	else if (iSelect >= m_PictureListBox.GetCount())
	{
		iSelect = m_PictureListBox.GetCount() - 1;
	}	 


	m_PictureListBox.SetCurSel(iSelect);

	m_PictureListBox.GetText(iSelect, strSelectName);

	auto iter = m_mapPngImg.find(strSelectName);

	if (iter == m_mapPngImg.end())
		return;


	m_AnimPicture.SetBitmap(*(iter->second)); // 애니메이션에 쓸 이미지 출력하고 있음

	int i = 0;

	for (; i < strSelectName.GetLength(); ++i)
	{
		// isdigit : 매개 변수로 전달받은 문자가 숫자형태의 글자인지 아니면 글자형태의 글자인지 판별하는 함수
		// 숫자형태의 글자로 판별하면 0이 아닌 값을 반환

		if (0 != isdigit(strSelectName[i]))
			break;
	}

	// Delete(index, count) : 인덱스 위치로부터 카운트만큼 문자를 삭제하는 함수
	strSelectName.Delete(0, i);

	//_tstoi : 문자를 정수형으로 변환하는 함수
	m_iDrawID = _tstoi(strSelectName);



	CImage* pImage = iter->second; //  이미지 포인터에 이미지 값을 저장


	CRect PictureControlRect; // Picture control 렉트 정보를 저장 ->렉트 크기
	m_AnimPicture.GetWindowRect(&PictureControlRect);
	ScreenToClient(&PictureControlRect);


	CImage resizedImage; // 크기에 맞게 조정하기 위해 저장할 이미지
	resizedImage.Create(PictureControlRect.Width(),
		PictureControlRect.Height(),
		pImage->GetBPP()); // 이미지 정보 출력 


	CDC* pDC = CDC::FromHandle(resizedImage.GetDC());
	CDC* pSrcDC = CDC::FromHandle(pImage->GetDC());


	// 이미지 스트레칭
	pDC->SetStretchBltMode(HALFTONE);
	pDC->StretchBlt(0, 0,
		PictureControlRect.Width(),
		PictureControlRect.Height(),
		pSrcDC, 0, 0, pImage->GetWidth(),
		pImage->GetHeight(),
		SRCCOPY);

	resizedImage.ReleaseDC();

	//	pImage->Destroy();
	//	pImage->Attach(resizedImage.Detach());



	// Picture Control에 이미지 그리기

	CDC* pPictureDC = m_AnimPicture.GetDC();
	CRect pictureRect;

	m_AnimPicture.GetClientRect(&pictureRect);

	pPictureDC->FillSolidRect(&pictureRect, RGB(255, 255, 255)); // Picture Control 배경을 흰색으로 채우기

	pImage->Draw(pPictureDC->m_hDC, pictureRect);

	m_AnimPicture.ReleaseDC(pPictureDC);






	// TODO: Add your control notification handler code here
	

	*pResult = 0;
}


void CDlgTab2::OnBnClickedButtonPlay()
{
	// TODO: Add your control notification handler code here


	CString			strSelectName;
	
	int iPlay = 0;
		
	m_PictureListBox.SetCurSel(iPlay);

	m_PictureListBox.GetText(iPlay, strSelectName);

	auto iter = m_mapPngImg.find(strSelectName);



	m_AnimPicture.SetBitmap(*(iter->second)); // 애니메이션에 쓸 이미지 출력하고 있음

	int i = 0;

	for (; i < strSelectName.GetLength(); ++i)
	{
		if (0 != isdigit(strSelectName[i]))
			break;
	}
	strSelectName.Delete(0, i);
	m_iDrawID = _tstoi(strSelectName);


	CImage* pImage = iter->second; //  이미지 포인터에 이미지 값을 저장

	CRect PictureControlRect; // Picture control 렉트 정보를 저장 ->렉트 크기
	m_AnimPicture.GetWindowRect(&PictureControlRect);
	ScreenToClient(&PictureControlRect);


	CImage resizedImage; // 크기에 맞게 조정하기 위해 저장할 이미지
	resizedImage.Create(PictureControlRect.Width(),
		PictureControlRect.Height(),
		pImage->GetBPP()); // 이미지 정보 출력 


	CDC* pDC = CDC::FromHandle(resizedImage.GetDC());
	CDC* pSrcDC = CDC::FromHandle(pImage->GetDC());


	// 이미지 스트레칭
	pDC->SetStretchBltMode(HALFTONE);
	pDC->StretchBlt(0, 0,
		PictureControlRect.Width(),
		PictureControlRect.Height(),
		pSrcDC, 0, 0, pImage->GetWidth(),
		pImage->GetHeight(),
		SRCCOPY);

	resizedImage.ReleaseDC();

	//	pImage->Destroy();
	//	pImage->Attach(resizedImage.Detach());



	// Picture Control에 이미지 그리기
	
	CDC* pPictureDC = m_AnimPicture.GetDC();
	CRect pictureRect;

	m_AnimPicture.GetClientRect(&pictureRect);

	pPictureDC->FillSolidRect(&pictureRect, RGB(255, 255, 255)); // Picture Control 배경을 흰색으로 채우기

	pImage->Draw(pPictureDC->m_hDC, pictureRect);

	m_AnimPicture.ReleaseDC(pPictureDC);

}
